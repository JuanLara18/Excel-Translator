"""
Excel Translation Script

This script reads an Excel file, translates the text from a specified column (assumed to be in German)
to English using the OpenAI API, and writes out a new Excel file with all the original data plus an
additional column containing the English translation.

Usage:
    python excel_translation.py --input input_file.xlsx --column German_Text [--output output_file.xlsx] [--batch_size 10]

If the output file is not specified, it will be automatically generated by appending '_translated'
to the input file's name.
"""

import os
import sys
import argparse
import logging
import datetime
from dotenv import load_dotenv
import pandas as pd
from tqdm import tqdm
from openai import OpenAI

# -----------------------
# Configuration and Setup
# -----------------------

# Set up logging
script_dir = os.path.dirname(os.path.abspath(__file__))
logging.basicConfig(
    filename=os.path.join(script_dir, 'excel_translation.log'),
    filemode='a',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Load environment variables from .env file
load_dotenv("OPENAI_API_KEY.env")
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
if not OPENAI_API_KEY:
    logging.error("OpenAI API key not found in environment variables.")
    raise ValueError("OpenAI API key not found in environment variables. Please set it in your .env file.")

# Initialize OpenAI client
client = OpenAI(api_key=OPENAI_API_KEY)

# Global constants for the OpenAI API call
MODEL_NAME = 'gpt-3.5-turbo'
SYSTEM_MESSAGE = "You are a helpful assistant that translates German text into English."
TRANSLATION_PROMPT = "Translate the following text from German to English:\n\n"

# -----------------------
# Functions
# -----------------------

def extract_translation(response_text: str) -> tuple[str, bool]:
    """
    Extracts translation from a formatted response.
    Returns the translation and a boolean indicating if the format was correct.
    
    :param response_text: The response text from the API
    :return: Tuple of (translation, is_valid_format)
    """
    try:
        # Check if response follows the exact format we expect
        if "TRANSLATION:" in response_text:
            # Split by TRANSLATION: and take the part after it
            parts = response_text.split("TRANSLATION:")
            if len(parts) == 2:
                translation = parts[1].strip()
                # Verify no explanatory text or quotes were added
                if not any(marker in translation for marker in 
                    ["means", "translates", "translation", "in English", '"', "'", "[", "]", "(", ")"]):
                    return translation, True
        return response_text, False
    except Exception as e:
        logging.error(f"Error extracting translation: {e}")
        return response_text, False

def create_translation_cache(df: pd.DataFrame, column: str) -> dict:
    """
    Creates a cache of unique texts to translate to avoid redundant API calls.
    
    :param df: DataFrame containing the texts to translate
    :param column: Name of the column containing texts to translate
    :return: Dictionary mapping unique texts to their frequency
    """
    return df[column].value_counts().to_dict()

def translate_text(text: str, translation_cache: dict = None) -> str:
    """
    Translates text from German to English, optimized for machine error descriptions.
    Uses caching to avoid redundant translations.
    
    :param text: A string in German to translate
    :param translation_cache: Cache of previous translations
    :return: The English translation as a string
    """
    if not isinstance(text, str) or not text.strip():
        return text

    system_message = """You are a technical translator specializing in machine error messages and technical descriptions. Follow these rules:

1. Translate from German to English precisely and technically
2. Use consistent technical terminology
3. Maintain any error codes or numbers exactly as they appear
4. Keep punctuation that could be part of error syntax
5. Do not add explanations or alternatives
6. Do not modify technical terms in brackets or parentheses
7. Preserve any variable names or placeholders exactly as they appear

Example 1:
Input: "Fehler E123: Motorüberhitzung"
Output: Error E123: Motor overheating

Example 2:
Input: "Wartung erforderlich: Öldruck niedrig [P045]"
Output: Maintenance required: Oil pressure low [P045]

Respond ONLY with the direct translation, nothing else."""

    try:
        # Check cache first if provided
        if translation_cache is not None and text in translation_cache:
            return translation_cache[text]

        response = client.chat.completions.create(
            model=MODEL_NAME,
            messages=[
                {"role": "system", "content": system_message},
                {"role": "user", "content": f"Translate: {text}"}
            ],
            temperature=0.1,
            max_tokens=150  # Reduced as error messages are typically short
        )

        translated_text = response.choices[0].message.content.strip()
        
        # Clean the translation while preserving technical elements
        translated_text = (translated_text
                         .replace('"', '')
                         .replace("'", "")
                         .replace(" translates to ", "")
                         .replace(" means ", "")
                         .replace(" in English", "")
                         .replace("Translation: ", "")
                         .strip())

        # Update cache if provided
        if translation_cache is not None:
            translation_cache[text] = translated_text

        logging.info(f"Translated: {text} → {translated_text}")
        return translated_text

    except Exception as e:
        logging.error(f"Translation error for '{text}': {str(e)}")
        return text

def process_excel(input_file: str, output_file: str, translate_col: str, 
                 new_col_name: str = "Translation", batch_size: int = 10):
    """
    Processes the Excel file by translating the content of the specified column.
    Uses caching for efficiency with repeated texts.
    """
    try:
        # Read the Excel file into a DataFrame
        df = pd.read_excel(input_file)
        logging.info(f"Loaded input file: {input_file} with {len(df)} rows.")

        # Validate column
        if translate_col not in df.columns:
            try:
                col_index = ord(translate_col.upper()) - ord('A')
                translate_col = df.columns[col_index]
                logging.info(f"Column letter provided converted to column name: {translate_col}")
            except Exception as e:
                logging.error(f"Invalid column identifier '{translate_col}': {e}")
                raise ValueError(f"Invalid column identifier '{translate_col}'.")

        # Create translation cache
        translation_cache = {}
        unique_texts = df[translate_col].value_counts()
        logging.info(f"Found {len(unique_texts)} unique texts to translate.")

        # First translate unique texts
        unique_translations = {}
        for text, count in tqdm(unique_texts.items(), desc="Translating unique texts"):
            translated = translate_text(text, translation_cache)
            unique_translations[text] = translated
            logging.info(f"Translated text (appears {count} times): {text} → {translated}")

        # Apply translations to DataFrame using the cache
        df[new_col_name] = df[translate_col].map(unique_translations)

        # Write the updated DataFrame to a new Excel file
        df.to_excel(output_file, index=False)
        logging.info(f"Output Excel file saved to: {output_file}")
        
        # Log translation statistics
        total_texts = len(df)
        unique_texts = len(unique_translations)
        saved_calls = total_texts - unique_texts
        logging.info(f"Translation statistics:")
        logging.info(f"Total texts: {total_texts}")
        logging.info(f"Unique texts: {unique_texts}")
        logging.info(f"API calls saved: {saved_calls}")

    except Exception as e:
        logging.error(f"Error processing Excel file: {e}")
        sys.exit(f"Error processing Excel file: {e}")

def generate_output_filename(input_file: str) -> str:
    """
    Generates an output filename by appending '_translated' before the file extension.
    
    :param input_file: The input file name.
    :return: The generated output file name.
    """
    base, ext = os.path.splitext(input_file)
    return f"{base}_translated{ext}"

def parse_args():
    """
    Parses command-line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Translate a specified column in an Excel file from German to English."
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to the input Excel file."
    )
    parser.add_argument(
        "--output",
        help="Path to the output Excel file. If not provided, the script will auto-generate one."
    )
    parser.add_argument(
        "--column",
        required=True,
        help="Column to translate (can be a column name or an Excel letter, e.g., 'B')."
    )
    parser.add_argument(
        "--new_col",
        default="Translation",
        help="Name of the new column to hold the English translation. Default is 'Translation'."
    )
    parser.add_argument(
        "--batch_size",
        type=int,
        default=10,
        help="Number of rows to process at a time. Default is 10."
    )
    return parser.parse_args()

# -----------------------
# Main Execution
# -----------------------

if __name__ == "__main__":
    args = parse_args()

    # Determine the output file name if not specified
    output_file = args.output if args.output else generate_output_filename(args.input)

    start_time = datetime.datetime.now()
    logging.info("Starting Excel translation process.")

    process_excel(
        input_file=args.input,
        output_file=output_file,
        translate_col=args.column,
        new_col_name=args.new_col,
        batch_size=args.batch_size
    )

    end_time = datetime.datetime.now()
    elapsed_time = (end_time - start_time).total_seconds()
    print(f"Translation completed in {elapsed_time:.2f} seconds. Output saved to {output_file}.")
    logging.info(f"Translation process finished in {elapsed_time:.2f} seconds.")
